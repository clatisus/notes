#+title: Haskell 99 Questions
#+author: Junjie Wu
#+date: <2022-11-28 Mon>

#+name: org-babel-haskell-formatter
#+begin_src emacs-lisp :var strr="" :exports code
(format "%s"
        (replace-regexp-in-string
         (rx (: "ghci" (| ">" "|") (* " ")))
         "" (format "%s" strr)))
#+end_src

#+RESULTS: org-babel-haskell-formatter

* 1 to 10: Lists
** Problem 1
Find the last element of a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
myLast :: [a] -> a
myLast = foldr1 (const id)
:}
myLast [1, 2, 3]
#+end_src

#+RESULTS:
: 3

** Problem 2
Find the last but one element of a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
myButLast :: [a] -> a
myButLast = fst . foldl (\(a, b) c -> (b, c)) (error "empty", error "too few")
:}
myButLast [1, 2, 3, 4]
#+end_src

#+RESULTS:
: 3

** Problem 3
Find the K-th element of a list. The first element in the list is number 1.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
elementAt :: [a] -> Int -> a
elementAt = flip $ (last .) . take
:}
elementAt "haskell" 5
#+end_src

#+RESULTS:
: e

#+begin_src haskell
take :: Int -> [a] -> [a]
     :: Int -> ([a] -> [a])
last :: [a] -> a
(last .) :: (b -> [a]) -> b -> a
         :: ([a] -> [a]) -> [a] -> a
#+end_src

** Problem 4
Find the number of elements of a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
myLength :: [a] -> Int
myLength = fst . last . zip [1..]
:}
myLength "Hello, world!"
#+end_src

#+RESULTS:
: 13

** Problem 5
Reverse a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
myReverse :: [a] -> [a]
myReverse = foldl (flip (:)) []
:}
myReverse "A man, a plan, a canal, panama!"
#+end_src

#+RESULTS:
: !amanap ,lanac a ,nalp a ,nam A

** Problem 6
Find out whether a list is a palindrome. A palindrome can be read forward or backward; e.g. (x a m a x).
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
isPalindrome :: Eq a => [a] -> Bool
isPalindrome = reverse >>= (==)
:}
isPalindrome [1, 2, 4, 2, 1]
#+end_src

#+RESULTS:
: True

** Problem 7
Flatten a nested list structure.

Transform a list, possibly holding lists as elements into a `flat' list by replacing each list with its elements (recursively).
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
data NestedList a = Elem a | List [NestedList a]
flatten :: NestedList a -> [a]
flatten (Elem x) = [x]
flatten (List xs) = xs >>= flatten
:}
flatten (List [Elem 1, List [Elem 2, List [Elem 3, Elem 4], Elem 5]])
#+end_src

#+RESULTS:
: (1 2 3 4 5)

** Problem 8
Eliminate consecutive duplicates of list elements.

If a list contains repeated elements they should be replaced with a single copy of the element. The order of the elements should not be changed.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
compress :: Eq a => [a] -> [a]
compress xs = foldr f (const []) xs Nothing
  where
    f x r a@(Just q) | x == q = r a
    f x r _ = x : r (Just x)
:}
compress "aaaabccaadeeee"
#+end_src

#+RESULTS:
: abcade

#+begin_src haskell
-- (Just x) stores the last element processed
-- taking [1, 2, 2] as example
1 `f` (2 `f` (2 `f` (const [])))
1 `f` |__________ r ___________| Nothing = 1 : r (Just 1)

2 `f` (2 `f` (const []))
2 `f` |______ r _______| (Just 1) = 2 : r (Just 2)

2 `f` (const [])
2 `f` |__ r ___| (Just 2) = r (Just 2)
#+end_src

** Problem 9
Pack consecutive duplicates of list elements into sub-lists. If a list contains repeated elements they should be placed in separate sub-lists.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Data.Maybe (fromJust)
:{
pack :: Eq a => [a] -> [[a]]
pack xs = foldr f ((: []) . fromJust) xs Nothing
  where
    f x r (Just q) | x == head q = r (Just (x : q))
    f x r (Just q) = q : r (Just [x])
    f x r Nothing = r (Just [x])
:}
pack ['a', 'a', 'a', 'a', 'b', 'c', 'c', 'a', 'a', 'd', 'e', 'e', 'e', 'e']
#+end_src

#+RESULTS:
: ["aaaa","b","cc","aa","d","eeee"]

** Problem 10
Run-length encoding of a list. Use the result of problem P09 to implement the so-called run-length encoding data compression method. Consecutive duplicates of elements are encoded as lists (N E) where N is the number of duplicates of the element E.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Data.List (group)
:{
encode :: Eq a => [a] -> [(Int, a)]
encode = map ((,) <$> length <*> head) . group
:}
encode "aaaabccaadeeee"
#+end_src

#+RESULTS:
: [(4,'a'),(1,'b'),(2,'c'),(2,'a'),(1,'d'),(4,'e')]

* 11 to 20: Lists, continued
** Problem 11
Modified run-length encoding.

Modify the result of problem 10 in such a way that if an element has no duplicates it is simply copied into the result list. Only elements with duplicates are transferred as (N E) lists.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Data.List (group)
:{
data ListItem a = Single a | Multiple Int a
  deriving (Show)
encode :: Eq a => [a] -> [(Int, a)]
encode = map ((,) <$> length <*> head) . group

encodeModified :: Eq a => [a] -> [ListItem a]
encodeModified = map encoder . encode
  where
    encoder (1, n) = Single n
    encoder (x, n) = Multiple x n
:}
encodeModified "aaaabccaadeeee"
#+end_src

#+RESULTS:
: [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']

** Problem 12
Decode a run-length encoded list.

Given a run-length code list generated as specified in problem 11. Construct its uncompressed version.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Data.List (group)
:{
decodeModified :: Eq a => [ListItem a] -> [a]
decodeModified = concatMap decoder
  where
    decoder (Single x) = [x]
    decoder (Multiple c x) = replicate c x
:}
decodeModified [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']
#+end_src

#+RESULTS:
: "aaaabccaadeeee"

** Problem 13
Run-length encoding of a list (direct solution).

Implement the so-called run-length encoding data compression method directly. I.e. don't explicitly create the sub-lists containing the duplicates, as in problem 9, but only count them. As in problem P11, simplify the result list by replacing the singleton lists (1 X) by X.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Data.List (group)
:{
encodeDirect :: Eq a => [a] -> [ListItem a]
encodeDirect [] = []
encodeDirect (x : xs) =
  let (group, rest) = span (== x) xs
   in encoder (Multiple (1 + length group) x) : encodeDirect rest
  where
    encoder (Multiple 1 x) = Single x
    encoder x = x
:}
encodeDirect "aaaabccaadeeee"
#+end_src

#+RESULTS:
: [Multiple 4 'a',Single 'b',Multiple 2 'c',Multiple 2 'a',Single 'd',Multiple 4 'e']

** Problem 14
Duplicate the elements of a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Control.Applicative ( (<**>) )
:{
dupli :: [a] -> [a]
dupli = (<**> [id, id])
:}
dupli [1, 2, 3]
#+end_src

#+RESULTS:
: [1,1,2,2,3,3]

Another brilliant way is
#+begin_src haskell
-- dupli = foldr (\x xs -> x : x : xs) []
-- dupli = foldr (\x -> (x :) . (x :)) []
dupli = foldr ((.) <$> (:) <*> (:)) []
#+end_src

** Problem 15
Replicate the elements of a list a given number of times.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Control.Applicative ( (<**>) )
:{
repli :: [a] -> Int -> [a]
-- repli = flip (flip ( <**> ) . (`replicate` id))
-- repli (x : xs) n = foldr (const (x :)) (repli xs n) [1 .. n]
repli xs n = xs >>= replicate n
:}
repli "abc" 3
#+end_src

#+RESULTS:
: "aaabbbccc"

** Problem 16
Drop every N-th element from a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
dropEvery :: [a] -> Int -> [a]
dropEvery = flip $ \n -> map snd . filter ((/= n) . fst) . zip (cycle [1 .. n])
:}
dropEvery "abcdefghiklmn" 3
#+end_src

#+RESULTS:
: abdeghkln

** Problem 17
Split a list into two parts; the length of the first part is given.

Do not use any predefined predicates.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
import Control.Arrow
:{
split :: [a] -> Int -> ([a], [a])
split (x : xs) n | n > 0 = (x :) . fst &&& snd $ split xs (n - 1)
split xs _ = ([], xs)
:}
split "abcdefghik" 3
#+end_src

#+RESULTS:
: ("abc","defghik")

** Problem 18
Extract a slice from a list.

Given two indices, i and k, the slice is the list containing the elements between the i-th and k-th element of the original list (both limits included). Start counting the elements with 1.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
slice :: [a] -> Int -> Int -> [a]
slice xs l r = drop (l - 1) $ take r xs
:}
slice ['a','b','c','d','e','f','g','h','i','k'] 3 7
#+end_src

#+RESULTS:
: cdefg

** Problem 19
Rotate a list N places to the left.

Hint: Use the predefined functions length and (++).
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
rotate :: [a] -> Int -> [a]
rotate x c = uncurry (flip (++)) $ splitAt (mod c (length x)) x
:}
-- rotate ['a','b','c','d','e','f','g','h'] 3
rotate ['a','b','c','d','e','f','g','h'] (-2)
#+end_src

#+RESULTS:
: "ghabcdef"

** Problem 20
Remove the K-th element from a list.
#+begin_src haskell :exports both :post org-babel-haskell-formatter(*this*)
:{
removeAt :: Int -> [a] -> (a, [a])
removeAt n x = (last prefix, init prefix ++ suffix)
  where
    (prefix, suffix) = splitAt n x
:}
removeAt 2 "abcd"
#+end_src

#+RESULTS:
: ('b',"acd")
